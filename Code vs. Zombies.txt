using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;


class Player
{
    const int PLAYER_MOVE_RANGE = 1000;
    const int ZOMBIE_MOVE_RANGE = 400;
    const int PLAYER_KILL_RANGE = 2000;
    const int ZOMBIE_KILL_RANGE = 400;
    const int ZONE_MAX_X = 16000;
    const int ZONE_MAX_Y = 9000;


    public struct Vector
    {
        public Vector(int x, int y)
        {
            X = x;
            Y = y;
        }

        public Vector(double x, double y)
        {
            X = (int)x;
            Y = (int)y;
        }

        public Vector(Vector a, Vector b)
        {
            X = b.X - a.X;
            Y = b.Y - a.Y;
        }

        public Vector(Vector direction, int length)
        {
            Vector newVector = (direction * length) / direction.Length;
            X = newVector.X;
            Y = newVector.Y;
        }

        public int X { get; set; }
        public int Y { get; set; }
        public int Length => (int)(Math.Sqrt(X*X + Y*Y));
        public Vector UnitVector => this / Length;

        public static Vector operator +(Vector a, Vector b) => new Vector(a.X + b.X, a.Y + b.Y);
        public static Vector operator -(Vector a) => new Vector(-a.X, -a.Y);
        public static Vector operator -(Vector a, Vector b) =>  a + (-b);
        public static Vector operator *(Vector a, double k) => new Vector(a.X * k, a.Y * k);
        public static Vector operator /(Vector a, double k) => a * (1/k);

        public override string ToString()
        {
            return $"(X: {X}, Y: {Y})";
        }

    }

    public static Vector Centroid(IEnumerable<Vector> vectors)
    {
        return new Vector(vectors.Sum(v => v.X), vectors.Sum(v => v.Y)) / vectors.Count();
    }



    public class Character
    {
        public Character(int id, Vector position)
        {
            Id = id;
            Position = position;
        }

        public int Id { get;}
        public Vector Position { get; set; }

        public Vector DistanceFrom(Vector target) => new Vector(this.Position, target);
    }

    public class Human : Character
    {
        public Human(int id, Vector position) : base(id, position)
        {
            TargetedBy = new();
        }

        public List<int> TargetedBy { get; set; }
    }


    public class Zombie : Character
    {
        public Zombie(int id, Vector position, Vector nextPosition) : base(id, position)
        {
            NextPosition = nextPosition;
        }

        public int KillRange => ZOMBIE_KILL_RANGE;
        public Vector NextPosition { get; set;}
        public Vector MoveDirection => new Vector(Position, NextPosition);

        public Character GetCurrentTarget(IEnumerable<Character> potentialTargets)
        {
            var target = potentialTargets.Aggregate((t1, t2) => DistanceFrom(t1.Position).Length < DistanceFrom(t2.Position).Length ? t1 : t2);
            if (target is Human human) human.TargetedBy.Add(this.Id);
            return target;
        }
    }

    public class Ash : Character
    {
        public Ash(int id, Vector position) : base(id, position) { }

        public Vector GetNextPosition(Vector targetPos)
        {
            Vector moveVector = new Vector(Position, targetPos);

            if (moveVector.Length <= PLAYER_MOVE_RANGE) return targetPos;

            return Position + new Vector(moveVector, PLAYER_MOVE_RANGE);
        }

        public int GetMoveScore(GameState gs, Vector targetPos)
        {
            var nextPos = GetNextPosition(targetPos);
            int zombieKillCount = gs.Zombies.Where(z => new Vector(z.NextPosition, nextPos).Length <= PLAYER_KILL_RANGE).Count();
            int humansAliveCount = gs.Humans.Count;

            int score = 0;

            for (int i = 0; i < zombieKillCount; i++)
            {
                score += humansAliveCount * humansAliveCount * 10 * gs.Fibonacci[i];
            }

            return score;
        }
    }


    public class GameState
    {
        public GameState()
        {
            Ash = new Ash(-1, new Vector(0, 0));
            Humans = new();
            Zombies = new();
            Fibonacci = new int[] { 1 };
        }

        public Ash Ash { get; set; }
        public List<Human> Humans { get; set; }
        public List<Zombie> Zombies { get; set; }

        public int[] Fibonacci { get; set; }

        public void UpdateAsh(Vector position)
        {
            Ash.Position = position;
        }

        public void UpdateHumans(IEnumerable<(int Id, Vector Position)> humansAlive)
        {
            if (Humans.Count == 0) Humans = humansAlive.Select(t => new Human(t.Id, t.Position)).ToList();
            else Humans.RemoveAll(h => !humansAlive.Any(a => a.Id == h.Id));
        }

        public void UpdateZombies(IEnumerable<(int Id, Vector Position, Vector NextPosition)> zombiesAlive)
        {
            if (Zombies.Count == 0)
            {
                InitializeFibonacci(zombiesAlive.Count());
                Zombies = zombiesAlive.Select(t => new Zombie(t.Id, t.Position, t.NextPosition)).ToList();
            }
            else
            {
                Zombies.RemoveAll(h => !zombiesAlive.Any(a => a.Id == h.Id));

                foreach (var z in Zombies)
                {
                    z.Position = zombiesAlive.Single(t => t.Id == z.Id).Position;
                    z.NextPosition = zombiesAlive.Single(t => t.Id == z.Id).NextPosition;
                }
            }
        }

        public void InitializeFibonacci(int zombieCount)
        {
            if (zombieCount == 1) return;

            int[] results = new int[zombieCount + 4];
            results[0] = 0;
            results[1] = 1;
            for (int i = 2; i < results.Length; i++)
            {
                results[i] = results[i-2] + results[i-1];
            }
            Fibonacci = results.TakeLast(results.Length - 2).ToArray();
        }
    }


    static void Main(string[] args)
    {
        GameState gs = new();
        
        while (true)
        { 
            gs.UpdateAsh(GetAshInput());
            gs.UpdateHumans(GetHumanInput());
            gs.UpdateZombies(GetZombieInput());


            //var nextPlayerPos = Centroid(humans.Select(h => h.Position)); //.Concat(zombies.Select(z => z.NextPosition)));

            var nextPlayerPos = gs.Humans.Single(h => h.Id == 0).Position;

            //var nextPlayerPos = gs.Ash.Position;

            Console.Error.WriteLine($"Move score: {gs.Ash.GetMoveScore(gs, nextPlayerPos)}");

            Console.WriteLine($"{nextPlayerPos.X} {nextPlayerPos.Y}"); // Your destination coordinates
        }
    }

    static string[] GetInputLines(int lineCount = 1)
    {
        var lines = new string[lineCount];

        for (int i = 0; i < lineCount; i++)
        {
            lines[i] = Console.ReadLine();
        }

        return lines;
    }

    static Vector GetAshInput()
    {
        string[] inputs = Console.ReadLine().Split(' ');
        int x = int.Parse(inputs[0]);
        int y = int.Parse(inputs[1]);
        return new Vector(x, y);
    }

    static IEnumerable<(int Id, Vector Position)> GetHumanInput()
    {
        int humanCount = int.Parse(Console.ReadLine());
        var humans = new (int Id, Vector Position)[humanCount];

        for (int i = 0; i < humanCount; i++)
        {
            string[] inputs = Console.ReadLine().Split(' ');
            int humanId = int.Parse(inputs[0]);
            int humanX = int.Parse(inputs[1]);
            int humanY = int.Parse(inputs[2]);

            humans[i] = (humanId, new Vector(humanX, humanY));
        }

        return humans;
    }

    static IEnumerable<(int Id, Vector Position, Vector NextPosition)> GetZombieInput()
    {
        int zombieCount = int.Parse(Console.ReadLine());
        var zombies = new (int Id, Vector Position, Vector NextPosition)[zombieCount];

        for (int i = 0; i < zombieCount; i++)
        {
            string[] inputs = Console.ReadLine().Split(' ');
            int zombieId = int.Parse(inputs[0]);
            int zombieX = int.Parse(inputs[1]);
            int zombieY = int.Parse(inputs[2]);
            int zombieXNext = int.Parse(inputs[3]);
            int zombieYNext = int.Parse(inputs[4]);

            zombies[i] = (zombieId, new Vector(zombieX, zombieY), new Vector(zombieXNext, zombieYNext));
        }

        return zombies;
    }
}